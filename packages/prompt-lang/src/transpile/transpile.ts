import fs from "fs";
import path from "path";
import { parseChatBlocks } from "../parseChatBlocks";
import { parseFrontmatterFromGlass } from "../parseFrontmatterFromGlass";
import { parseGlassFunctions } from "../parseGlassFunctions";
import { parseGlassMetadata } from "../parseGlassMetadata";
import { transpileToJavascript } from "./transpileToJavascript";
import { transpileToPython } from "./transpileToPython";
import { transpileToRuby } from "./transpileToRuby";
import { transpileToTypescript } from "./transpileToTypescript";

export function transpileFile(
  filePath: string,
  language: string,
  defaultModel?: string
) {
  const promptfile = fs.readFileSync(filePath, "utf-8");
  const basename = path.basename(filePath);
  const exportName = normalizeFilename(basename) + "Prompt";
  const out = transpile(promptfile.toString(), language, {
    defaultModel,
    exportName,
    skipPrefix: true,
  });
  return { out, exportName };
}

export function transpile(
  text: string,
  language: string,
  options: {
    exportName?: string;
    defaultModel?: string;
    skipPrefix?: boolean;
  }
) {
  if (
    language !== "typescript" &&
    language !== "python" &&
    language !== "javascript" &&
    language !== "ruby"
  ) {
    throw new Error(`Invalid language: ${language}`);
  }
  const frontmatter = parseFrontmatterFromGlass(text);
  const model = frontmatter?.model ?? options.defaultModel;
  if (!model) {
    throw new Error(`No model specified in frontmatter or defaultModel`);
  }

  const blocks = parseChatBlocks(text);
  const variables = parseGlassMetadata(text).interpolationVariables;
  const functions = parseGlassFunctions(text);
  let code = "";
  try {
    if (language === "typescript") {
      code = transpileToTypescript(
        options.exportName || "prompt",
        blocks,
        variables,
        functions,
        model
      );
      if (!options.skipPrefix) {
        code = transpilePrefix(language) + "\n\n" + code;
      }
    } else if (language === "javascript") {
      code = transpileToJavascript(blocks, variables, functions, model);
    } else if (language === "python") {
      code = transpileToPython(blocks, variables, functions, model);
    } else if (language === "ruby") {
      code = transpileToRuby(blocks, variables, functions, model);
    }
    if (code.length === 0) {
      throw new Error(`No code was generated for ${language}`);
    }
    return code;
  } catch (error) {
    console.error(error);
    throw error;
  }
}

export function transpilePrefix(language: string) {
  if (language !== "typescript") {
    return "";
  }
  return `/* eslint-disable */
// THIS FILE WAS AUTOGENERATED -- DO NOT EDIT

interface ChatBlock {
  role: 'system' | 'user' | 'assistant' | 'function'
  content: string
  name?: string
  type?: 'function_call'
}

interface LLMFunction {
  name: string
  description?: string
  parameters?: any
  testValue?: string
}

interface Prompt<T> {
  model: string
  blocks: (args: T) => ChatBlock[]
  functions: LLMFunction[]
}`;
}

export function normalizeFilename(fileName: string) {
  if (fileName.endsWith(".prompt")) {
    fileName = fileName.slice(0, -6);
  }

  // strip non-alpha characters
  return fileName.replace(/[^a-zA-Z]/g, "");
}
