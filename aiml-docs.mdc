---
description: Core AIML SpecStates can only be activ
globs: 
alwaysApply: false
---
# AIML: AI Markup Language

AIML is a powerful MDX-based markup language for defining AI agent workflows. It combines the expressiveness of MDX with a structured state machine approach inspired by SCXML, allowing you to create sophisticated AI agents with deterministic flows.

## File Structure

### Headers

Headers define metadata about your AIML file using YAML frontmatter at the beginning of the file. They specify crucial information like the agent name, input schema, and whether the file is an AIML root.

```mdx
---
name: RecipeGenerator                # Name of your AIML agent
inputSchema:                         # JSON Schema defining expected input
  type: object
  properties:
    ingredients:
      type: array
      items:
        type: string
      description: List of ingredients available to use
    dietaryRestrictions:
      type: array
      items:
        type: string
      description: Dietary restrictions to consider
    mealType:
      type: string
      enum: ["breakfast", "lunch", "dinner", "dessert", "snack"]
      description: Type of meal to generate
root: true                           # Indicates this is a root AIML file
---
```

**Key Header Properties:**

- `name`: The name of your AIML agent, used for identification purposes
- `inputSchema`: JSON Schema defining the expected input structure
- `root`: When set to `true`, indicates this is a root AIML file (an entry point)
- `outputSchema`: (Optional) JSON Schema defining the expected output structure

For root AIML files, the `inputSchema` defines the expected API request payload structure. For non-root files (imported as components), the `inputSchema` defines the props expected when imported.

### Comments

AIML supports MDX-style comments which are not only useful for code readability but also provide optimization hints for the AIML tooling:

```mdx
{/* 
This implements an automated code reviewer that can analyze pull requests,
identify issues, and provide detailed feedback. It aims to mimic a thorough human
code review process with multiple specialized analyses.

The workflow fetches code from a repository, performs various analyses including
security scanning, performance evaluation, code quality assessment, and test coverage.
It then synthesizes findings into actionable feedback organized by priority and category.

This can help development teams maintain code quality without manual review overhead.
*/}
```

Comments should focus on explaining the high-level purpose and approach of your AIML agent, providing context that can help with debugging, optimization, and understanding the workflow.

### Imports

AIML supports importing other files, including other AIML files, JSON data, and code files (JS, TS, Python, etc.). When importing non-AIML files, they are treated as raw strings.

```mdx
// Import other AIML files as components
import ReasoningChainState from "./ReasoningChainState.aiml"

// Import data files
import SecurityRules from "./SecurityRules.json"
import CodeQualityRules from "./CodeQualityRules.json"

// Import code files (treated as strings)
import TestingTools from "./TestingTools.js"
import DataProcessingScript from "./process.py"
```

Imported AIML files can be used as custom elements:

```mdx
<ReasoningChainState problem={ctx.datamodel.problem} />
```

Imported JSON files are automatically parsed and can be used directly:

```mdx
<script>
  const securityRules = JSON.parse(SecurityRules);
  // Use securityRules in your logic
</script>
```

Imported code files can be used in script elements:

```mdx
<script>
  // JavaScript can be used directly
  const result = TestingTools
</script>
```

## Core Concepts

### Workflow vs. Non-Workflow

AIML supports two primary modes:

#### Workflow Mode

In workflow mode, you explicitly define a workflow with an initial state:

```mdx
<workflow initial="fetchCode">
  <datamodel>
    {/* Global data definitions */*}
  </datamodel>

  <state id="fetchCode">
     {/* state definition */*}
    <transition target="analyzeCode" />
  </state>
  
  <state id="analyzeCode">
     {/* state definition */*}
  </state>
  
  {/* More states  */*}
</workflow>
```

In this mode:
- The `initial` attribute explicitly defines the starting state
- Execution follows a deterministic path defined by transitions
- States can only be active one at a time (unless using parallel states)

#### Non-Workflow Mode

In non-workflow mode, you don't use the `<workflow>` element, and instead define states directly:

```mdx
This markdown text serves as a system prompt to guide the initial state selection.

<state id="understand" description="This state defines the first step of the reasoning chain.">
  {/* State definition */}
</state>

<state id="analyze" description="This state handles detailed analysis.">
  {/* State definition */}
</state>
```

In this mode:
- The initial state is selected dynamically by the model based on the markdown text before the first state is defined
- State descriptions help the model understand what top level state to choose
- The initial state will only be selected from a top level state or state-like element, e.g. `<state>`, `<parallel>`, or `<final>`
- Simply as the models choice means the response is simply the model replying without going through any flow.
- After initial selection, execution follows normal state transition rules

### States and Transitions

States are the fundamental building blocks of AIML workflows. Each state represents a discrete step in your agent's execution flow.

#### Basic State Structure

```mdx
<state id="analyzeCode">
  <datamodel>
    {/* State-local data definitions */}
    <data id="localVar" type="string" value="initial value" />
  </datamodel>
  
  <onentry>
    {/* Actions to execute when entering the state */}
    <script>
      ctx.log("Entered analyze state");
    </script>
    <log value={(ctx) => 'Analyzing ' + ctx.datamodel.fileName} />
  </onentry>
  
  {/* Primary state content: LLM calls, tool calls, etc. */}
  <llm model="gpt-4o" temperature={0.1}>
    <prompt>Analyze this code: {ctx.datamodel.codeContent}</prompt>
  </llm>
  
  <script>
    ctx.datamodel.analysis = ctx.lastElement.output;
  </script>
  
  <onexit>
    {/* Actions to execute when exiting the state */}
    <log value="Exiting analyze state" />
  </onexit>
  
  {/* Define where to go next */}
  <transition target="generateFeedback" />
</state>
```

#### Transitions

Transitions define how execution moves between states:

```mdx
{/* Simple transition */}
<transition target="nextState" />

{/* Conditional transition */}
<transition target="errorState" cond={(ctx) => ctx.datamodel.hasError} />

{/* Alternative transitions based on conditions */}
<if cond={(ctx) => ctx.datamodel.score > 80}>
  <transition target="highScore" />
<elseif cond={(ctx) => ctx.datamodel.score > 50} />
  <transition target="mediumScore" />
<else />
  <transition target="lowScore" />
</if>
```

#### Final States

Final states mark the end of a workflow:

```mdx
<state id="complete" final="true">
  <onentry>
    <sendObject>
      {
        "result": ctx.datamodel.analysis,
        "recommendations": ctx.datamodel.recommendations
      }
    </sendObject>
  </onentry>
</state>
```

### Data Model

The data model defines the variables available throughout your AIML workflow.

#### Global Data Model

Data defined at the workflow level is accessible to all states:

```mdx
<workflow initial="start">
  <datamodel>
    <data id="userInput" type="string">{ctx.workflowInput.userMessage}</data>
    <data id="analysisResults" type="json" value={{}} />
    <data id="recommendations" type="array" value={[]} />
  </datamodel>
  
  {/* States */}
</workflow>
```

#### State-Local Data Model

Data can also be defined locally within a state, accessible only within that state and its children:

```mdx
<state id="analyze">
  <datamodel>
    <data id="tempResults" type="json" value={{}} />
    <data id="processingComplete" type="boolean" value={false} />
  </datamodel>
  
  {/* State content */}
</state>
```

#### Data Types

AIML supports the following data types:

- `string`: Text values
- `boolean`: True/false values
- `integer`: Whole numbers
- `number`: Numeric values (includes decimals)
- `array`: Ordered lists of items
- `json`: JSON objects or structures (requires an aditional schema field to be set on the element)

#### Data Access

Data can be accessed and modified through:

1. Direct references in JSX expressions (only for userInput): {userInput.variableName}
2. In functional expressions: `value={(ctx) => ctx.datamodel.value + 1}`
3. As a child string in an element where the direct parent element is a closure providing the ctx used: `<script>console.log(ctx.lastElement.output)</script>`

## Elements Reference

### Structural Elements

#### `<workflow>`

Defines a complete workflow with states and transitions. It is optional, and exists to provide a more controlled generation flow

```mdx
<workflow initial="firstState">
  {/* Workflow content */}
</workflow>
```

Attributes:
- `initial`: ID of the starting state

#### `<state>`

Defines a single state in the workflow, or within the prompt

```mdx
<state id="processData" description="Processes the input data">
  {/* State content */}
</state>
```

Attributes:
- `id`: Unique identifier for the state
- `description`: (Optional) Description of the state's purpose
- `final`: (Optional) Boolean indicating if this is a final state

#### `<parallel>`

Allows multiple states to be active simultaneously.

```mdx
<parallel id="multiProcess">
  <state id="processImages">
    {/* Image processing */}
  </state>
  <state id="processText">
    {/* Text processing */}
  </state>
</parallel>
```

#### `<final>`

Marks a terminal state in the workflow.

```mdx
<final id="complete">
  <onentry>
    <sendObject>
      {
        "result": "success",
        "data": ctx.datamodel.output
      }
    </sendObject>
  </onentry>
</final>
```

### Data Management

#### `<datamodel>`

Container for data declarations.

```mdx
<datamodel>
  <data id="variable1" type="string" value="initial value" />
  <data id="variable2" type="json" value={{ key: "value" }} />
</datamodel>
```

#### `<data>`

Declares a single variable.

```mdx
<data id="score" type="number" value={0} />
<data id="userInput" type="string">{ctx.workflowInput.userMessage}</data>
```

Attributes:
- `id`: Variable name
- `type`: Data type (string, boolean, integer, number, array, json, any)
- `value`: Initial value (optional)

#### `<assign>`

Sets a value to a data model variable.

```mdx
<assign location="score" value={100} />
<assign location="results[0]" value={(ctx) => ctx.datamodel.tempResult * 2} />
```

Attributes:
- `location`: Variable or path to update
- `value`: Direct value to assign
- `expr`: Expression to evaluate and assign

### Control Flow

#### `<onentry>`

Contains actions to execute when entering a state.

```mdx
<onentry>
  <log expr="'Entered state'" />
  <script>
    ctx.datamodel.startTime = Date.now();
  </script>
</onentry>
```

#### `<onexit>`

Contains actions to execute when exiting a state.

```mdx
<onexit>
  <log expr="'Exiting state'" />
  <assign location="processingTime" expr={(ctx) => Date.now() - ctx.datamodel.startTime} />
</onexit>
```

#### `<transition>`

Defines movement between states.

```mdx
<transition target="nextState" />
<transition target="errorState" cond={(ctx) => ctx.datamodel.hasError} />
```

Attributes:
- `target`: ID of the target state
- `cond`: (Optional) Condition that must be true for the transition to occur

#### `<if>`, `<elseif>`, `<else>`

Conditional execution of actions.

```mdx
<if cond={(ctx) => ctx.datamodel.score > 80}>
  <assign location="grade" value="A" />
<elseif cond={(ctx) => ctx.datamodel.score > 70} />
  <assign location="grade" value="B" />
<elseif cond={(ctx) => ctx.datamodel.score > 60} />
  <assign location="grade" value="C" />
<else />
  <assign location="grade" value="F" />
</if>
```

> Note: `<else>` and `<elseif>` must be nested within their parent `<if>` element

#### `<foreach>`

Iterates over a collection of items.

```mdx
<foreach item="file" array={(ctx) => ctx.datamodel.files}>
  <script>
    ctx.log("Processing file: " + file);
    // Process each file
  </script>
</foreach>
```

Attributes:
- `item`: Variable name for the current item
- `array`: The collection to iterate over

#### `<script>`

Executes JavaScript code.

```mdx
<script>
  // Access data using ctx.datamodel
  const words = ctx.datamodel.text.split(' ');
  ctx.datamodel.wordCount = words.length;
  
  // Log information
  ctx.log(`Found ${ctx.datamodel.wordCount} words`);
  
  // You can use complex JS logic here
  const filteredWords = words.filter(word => word.length > 5);
  ctx.datamodel.longWords = filteredWords;
</script>
```

### AI Interaction

#### `<llm>`

Configures and executes an LLM call.

```mdx
<llm model="gpt-4o" temperature={0.7} max_tokens={1000}>
  <prompt>
    Generate a creative story about:
    Theme: {ctx.datamodel.theme}
    Characters: {ctx.datamodel.characters.join(', ')}
    Setting: {ctx.datamodel.setting}
    
    The story should be approximately 500 words long and include dialogue.
  </prompt>
</llm>

<script>
  // Access the LLM response
  ctx.datamodel.story = ctx.lastElement.output;
</script>
```

Attributes:
- `model`: The LLM model to use
- `temperature`: Creativity control (0.0-1.0)
- `max_tokens`: Maximum response length
- More model-specific parameters can be added

#### `<toolcall>`

Executes a specific tool call.

```mdx
<toolcall name="searchDatabase">
  <param name="query" expr={(ctx) => "user:" + ctx.datamodel.userId} />
  <param name="limit" value={10} />
</toolcall>

<script>
  // Access the tool call results
  ctx.datamodel.searchResults = ctx.lastElement.output;
</script>
```

Attributes:
- `name`: The name of the tool to call

Children:
- `<param>`: Parameters to pass to the tool

### Output Management

#### `<log>`

Outputs a message to the execution log.

```mdx
<log value="Processing complete" />
<log value={(ctx) => 'Found ' + ctx.datamodel.results.length + ' results'} />
```

Attributes:
- `expr`: Expression to evaluate and log

#### `<sendText>`

Sends text content to the client.

```mdx
<sendText>
  Thank you for your query. Based on the information provided, here are my findings:
  
  {ctx.datamodel.analysis}
  
  I hope this helps!
</sendText>
```

#### `<sendToolCalls>`

Sends tool call results to the client.

```mdx
<sendToolCalls tools={ctx.datamodel.generatedTools} />
```

Attributes:
- `tools`: Array of tool call objects to send

#### `<sendObject>`

Sends a structured object to the client.

```mdx
<sendObject>
  {
    "analysis": ctx.datamodel.analysis,
    "recommendations": ctx.datamodel.recommendations,
    "score": ctx.datamodel.overallScore,
    "processingTime": ctx.datamodel.processingTime
  }
</sendObject>
```

#### `<onerror>`

Contains error handling logic.

```mdx
<onerror>
  <log value={(ctx) => `Error occurred: "${ctx._event.data.message}"`/>
  <sendText>
    I apologize, but an error occurred while processing your request.
    Error details: {ctx._event.data.message}
  </sendText>
</onerror>
```

#### `<onchunk>`

Handles streaming chunks of data from an LLM.

```mdx
<onchunk>
  <sendText>{ctx._chunk.text}</sendText>
</onchunk>
```

## Context Object

The `ctx` object provides access to the current execution context throughout your AIML workflow. It's available in expressions, scripts, and other elements.

Key properties and methods:

```javascript
// Access data model variables
ctx.datamodel.variableName

// Access the output of the previous element
ctx.lastElement.output

// Log messages during execution
ctx.log("Informational message")

// Access workflow input
ctx.workflowInput.userMessage

// Access event data in event handlers
ctx._event.data

// Access chunk data in streaming handlers
ctx._chunk.text
```

## JavaScript Integration

AIML provides extensive JavaScript integration through the `<script>` element and expressions.

### Inline Functions

You can use inline functions in expressions to access the context:

```mdx
<assign location="formattedName" value={(ctx) => ctx.datamodel.name.toUpperCase()} />
<log value={(ctx) => `Processed ${ctx.datamodel.items.length} items`} />
```

### Script Blocks

Use script blocks for more complex logic:

```mdx
<script>
  // Complex processing logic
  const rawData = ctx.datamodel.inputData;
  const processed = rawData.map(item => {
    return {
      id: item.id,
      name: item.name.trim(),
      score: calculateScore(item.metrics)
    };
  });
  
  // Custom helper function
  function calculateScore(metrics) {
    return metrics.reduce((sum, val) => sum + val, 0) / metrics.length;
  }
  
  // Store results back to datamodel
  ctx.datamodel.processedData = processed;
</script>
```

### Importing External JavaScript

You can import JavaScript files and use them in your AIML:

```mdx
import DataProcessor from "./dataProcessing.js"

<script>
  // Use the imported JavaScript
  const processor = eval(DataProcessor);
  ctx.datamodel.processedData = processor.process(ctx.datamodel.rawData);
</script>
```

## Advanced Patterns

### Modular AIML Components

Break down complex flows into reusable components:

```mdx
// ComponentA.aiml
---
name: DataProcessor
inputSchema:
  type: object
  properties:
    data:
      type: object
      description: Raw data to process
root: false
---

<state id="process">
  {/* Processing logic */}
  <script>
    // Process the input data
    const processed = transform(userInput.data);
    
    // Return the processed data
    return {
      result: processed
    };
  </script>
</state>
```

```mdx
// Main.aiml
import DataProcessor from "./ComponentA.aiml"

<workflow initial="start">
  <state id="start">
    {/* Setup data */}
    <transition target="process" />
  </state>
  
  <state id="process">
    <DataProcessor data={ctx.datamodel.rawData} />
    <script>
      // Access the component's return value
      ctx.datamodel.processedData = ctx.lastElement.output.result;
    </script>
    <transition target="finish" />
  </state>
  
  <state id="finish" final="true">
    {/* Final output */}
  </state>
</workflow>
```

### Error Handling Patterns

Implement robust error handling:

```mdx
<state id="processData">
  <onentry>
    <script>
      try {
        // Attempt processing
        ctx.datamodel.result = processData(ctx.datamodel.input);
      } catch (error) {
        // Handle error
        ctx.datamodel.error = {
          message: error.message,
          code: error.code || 'UNKNOWN',
          timestamp: new Date().toISOString()
        };
      }
    </script>
  </onentry>
  
  <if cond={(ctx) => ctx.datamodel.error}>
    <transition target="handleError" />
  <else />
    <transition target="success" />
  </if>
</state>

<state id="handleError">
  <onentry>
    <log value={(ctx) => 'Error occurred: ' + ctx.datamodel.error.message} />
    <sendText>
      I encountered an error while processing your request: 
      {ctx.datamodel.error.message}
      
      Please try again with different inputs.
    </sendText>
  </onentry>
</state>
```

## Debugging Tips

1. **Use logs extensively**: The `<log>` element provides visibility into workflow execution

   ```mdx
   <log value={ctx => `Entering state: "${ctx._state}"`} />
   <log value={(ctx) => 'Data: ' + JSON.stringify(ctx.datamodel.someObject)} />
   ```

2. **Check data types**: Ensure your data types match expectations

   ```mdx
   <script>
     // Debug data types
     ctx.log(`Variable type: ${typeof ctx.datamodel.variable}`);
     if (Array.isArray(ctx.datamodel.items)) {
       ctx.log(`Array length: ${ctx.datamodel.items.length}`);
     }
   </script>
   ```

3. **Validate JSON parsing**: When using `JSON.parse()`, always wrap in try/catch

   ```mdx
   <script>
     try {
       const data = JSON.parse(ctx.lastElement.output);
       ctx.datamodel.parsedData = data;
     } catch(e) {
       ctx.log("JSON parse error: " + e.message);
       ctx.log("Raw content: " + ctx.lastElement.output);
       ctx.datamodel.parsedData = null;
       ctx.datamodel.parseError = true;
     }
   </script>
   ```

## Best Practices

1. **Structure your workflow clearly**:
   - Use descriptive state IDs
   - Add comments to explain complex logic
   - Group related states together

2. **Handle errors gracefully**:
   - Use try/catch in scripts
   - Provide fallbacks for LLM and tool calls
   - Include informative error messages

3. **Keep state transitions explicit**:
   - Clearly define where each state leads
   - Use conditions to handle different scenarios
   - Document transition logic in comments

4. **Organize data efficiently**:
   - Define global data at the workflow level
   - Use state-local data for temporary variables
   - Clean up temporary data when no longer needed

5. **Optimize LLM prompts**:
   - Be specific in your instructions
   - Structure output requests clearly
   - Request JSON when processing structured data

6. **Make your AIML modular**:
   - Break complex workflows into components
   - Create reusable state patterns
   - Import specialized functionality when needed

7. **Follow proper nesting structure**:
   - Ensure `<else>` and `<elseif>` are nested within `<if>`
   - Don't place `<toolcall>`, `<llm>`, or `<send*>` elements directly inside `<on*>` elements
   - Maintain clear parent-child relationships in all elements 