---
description: Docs for SCXML elements/tags
globs: 
alwaysApply: false
---
# SCXML Elements

Below is a high-level but thorough overview of SCXML (State Chart XML), its core elements, their attributes ("props"), and their typical hierarchy. SCXML is a specification that describes state machines and state charts using an XML style notation. It can be used to define the behavior of systems with hierarchical and parallel states.

## 1. The `<scxml>` Root Element

- **Purpose**: Serves as the root container for the entire state machine definition.
- **Key Attributes**:
  - `version`: SCXML version (e.g., `"1.0"`).
  - `initial`: The ID of the state that will be active first.
  - `name`: An optional name for the state machine.
  - `profile`: An optional string describing an SCXML "profile" (execution environment).
  - `datamodel`: Specifies the type of data model used (e.g., `"ecmascript"`).
  - `binding`: Either `"early"` or `"late"` to define when data is bound.
  - Common attributes such as `xmlns`, etc.
- **Allowed Children**:
  - `<state>` / `<parallel>` / `<final>` (top-level states)
  - `<datamodel>` (for global data definitions)
  - `<script>` (top-level script)
  - `<onentry>`, `<onexit>` (though these are less common directly inside `<scxml>`)
  - `<transition>` (a top-level transition, also less common in practice)

---

## 2. State Elements

SCXML allows multiple types of "state-like" elements. Each of these represents a node in the state machine.

### 2.1 `<state>`

- **Purpose**: In SCXML, a <state> is the most common building block for defining your state machine. A <state> can be atomic (no further child states) or compound (contains child states). This nesting lets you define hierarchical state machines.
- **Key Attributes**:
  - `id`: Uniquely identifies the state.
  - `initial`: The ID of the initially active **child** state (if this `<state>` itself has nested states).
  - `xml:id`: Sometimes used to uniquely identify the XML element in certain tools.
- **How it functions**

  1. **Identifier & Reference by `id`:**

  - Each `<state>` can (and usually should) have an `id`.
  - Transitions in your SCXML often use this `id` as a `target` (e.g. `target="myState"`).

  2. **Atomic vs. Compound States:**

  - **Atomic State**: A `<state>` with **no** child `<state>`, `<parallel>`, or `<final>` elements.
  - **Compound State**: A `<state>` that **does** contain child `<state>`, `<parallel>`, or `<final>` elements.
  - You only ever occupy **one** child of a compound `<state>` at a time (unless it’s a `<parallel>`).

  3. **Initial Child State(s):**

  - If a `<state>` is compound, it must say which child state(s) to enter first.
  - You can specify this with:
    - An `initial="someChildId"` attribute, or
    - An `<initial>` element inside `<state>` (useful if you need executable content in that initial transition).
  - If neither is used, the default initial state is simply the first child `<state>` in document order.

  4. **Entering and Exiting a `<state>`:**

  - You can define `<onentry>` blocks which run actions whenever the machine enters that state.
  - You can define `<onexit>` blocks which run actions whenever the machine leaves that state.
  - These blocks may contain any executable content (such as `<assign>`, `<send>`, `<script>`, `<log>`, etc.).

  5. **Transitions from a `<state>`:**

  - Inside a `<state>`, you typically define `<transition>` elements.
  - A transition usually has an `event` attribute (the event name that triggers it) and a `target` attribute (where to go next).
  - You can also have transitions with **no** `event` attribute (eventless) or with conditions (`cond=...`).
  - If multiple transitions are eligible, the SCXML processor uses the first match in document order.

  6. **Final States Within a `<state>`:**

  - A `<final>` child signifies that the **parent** `<state>` has completed its “work.”
  - Once a `<final>` child is entered, the SCXML interpreter raises a `done.state.<parentId>` event.
  - You can listen for `done.state.<parentId>` in any ancestor state.

  7. **Optional Data Model:**

  - A `<state>` may include `<datamodel>`, `<onentry>`, `<onexit>`, `<invoke>`, or `<history>` elements if needed.
  - If your SCXML uses “late” binding, the `<datamodel>` within a `<state>` is not initialized until that state is actually entered.

- **Allowed Children**:
  - **Nested states**: `<state>`, `<parallel>`, `<final>`
  - **Transition elements**: `<transition>`
  - **Executable content**:
    - `<onentry>` and `<onexit>`
    - `<on>` (event-specific handlers)
    - `<script>`
    - `<__any custom element__>` (any custom element defined beyond the standard spec)
    - `<datamodel>` (to define or override data)
    - `<history>` (history pseudo-state)
  - **Final** states (`<final>`) can also appear as children if you want a final child-state inside this `<state>`.

#### Minimal Example

```xml
<scxml version="1.0" xmlns="http://www.w3.org/2005/07/scxml"
       initial="startState" datamodel="ecmascript">

  <!-- Top-level states -->
  <state id="startState">
    <onentry>
      <log expr="'Entering startState'"/>
    </onentry>
    <transition event="goNext" target="someOtherState"/>
  </state>

  <state id="someOtherState">
    <onentry>
      <log expr="'Inside someOtherState'"/>
    </onentry>
    <transition event="reset" target="startState"/>
  </state>

</scxml>
```

**Behavior** (from your perspective as the author):

- The machine starts in `startState`.
- When `goNext` arrives, it transitions to `someOtherState`.
- If a `reset` event comes in, it transitions back to `startState`.

### 2.2 `<parallel>`

- **Purpose**: A `<parallel>` element is a special kind of SCXML state that allows you to have multiple “regions” of activity running at the same time. Conceptually, all child states of the `<parallel>` are entered together, remain active together, and each child can handle events independently. This is different from a “regular” (sequential) `<state>`, where only **one** child state at a time can be active.
- **How it functions**
  - When the state machine enters a `<parallel>` parent, **all** of its child `<state>` or nested `<parallel>` elements become active at once (each child is entered into its own initial configuration).
  - A `<parallel>` is considered “finished” only when **all** of its child states have reached their respective final states (`<final>`).
  - At that moment, the SCXML interpreter automatically raises a `done.state.<id>` event for the `<parallel>` element (where `<id>` is that parallel’s `id`). You can use `done.state.myParallelID` as a trigger to transition out of the parallel’s parent.
  - **Exiting a `<parallel>` Exits All Children:** If one of the child states triggers a transition **that targets something outside** of the `<parallel>`, then **all** children of the `<parallel>` are exited together.This is because from the developer’s standpoint, a single exit from the `<parallel>` means you have decided to leave that entire parallel region.
- **Key Attributes**:
  - `id`: Unique ID of this parallel state.
- **Allowed Children** (similar to `<state>`):

  - `<state>`, `<parallel>`, `<final>` (the parallel sub-states or sub-regions)
  - `<transition>` (outgoing transitions from the parallel itself)
  - `<onentry>`, `<onexit>`, `<on>`, `<__any custom element__>`, `<script>`, `<datamodel>`, `<history>`

  Below is a **developer-oriented** explanation of how **Parallel Elements** (`<parallel>`) in SCXML work—what you need to know when authoring SCXML with parallel states. This focuses on **how you design** state machines using `<parallel>`, rather than the internal algorithm the runtime uses to process them.

#### Minimal Example

Below is a trimmed-down example demonstrating a simple `<parallel>` with two child states:

```xml
<scxml version="1.0" xmlns="http://www.w3.org/2005/07/scxml"
       initial="p" datamodel="ecmascript">

  <parallel id="p">
    <transition event="done.state.p" target="finished"/>

    <state id="childA" initial="A1">
      <state id="A1">
        <transition event="goA2" target="A2"/>
      </state>
      <final id="A2"/>
    </state>

    <state id="childB" initial="B1">
      <state id="B1">
        <transition event="goB2" target="B2"/>
      </state>
      <final id="B2"/>
    </state>
  </parallel>

  <final id="finished"/>
</scxml>
```

**Behavior** (from your perspective as the author):

- When `<parallel id="p">` starts, `childA` enters `A1` and `childB` enters `B1`.
- If an event `goA2` arrives, `childA` moves to `A2` (which is a `<final>`). Meanwhile, `childB` is **still in** `B1`, waiting.
- If an event `goB2` eventually arrives, `childB` moves to `B2` (also a `<final>`).
- **Now** both `childA` and `childB` are in `<final>` states, so the parent `<parallel id="p">` emits `done.state.p`, causing a transition to `finished`.

### 2.3 `<final>`

- **Purpose**: A specialized state that indicates completion of its parent region when entered.
- **Key Attributes**:
  - `id`: Unique ID of this final state.
- **Allowed Children**:
  - `<onentry>`, `<onexit>`, `<on>`, `<script>`, `<__any custom element__>`, `<datamodel>` (similar to a normal state but typically no child states)
  - Usually no further nested states are inside `<final>`.

### 2.4 `<history>`

- **Purpose**: A `<history>` state in SCXML is a **pseudo-state** that allows you to remember (or “record”) which sub-states were active the last time the parent state was exited. Later, when a transition re-enters that parent via this `<history>` state, you can “resume” from where you left off. This history can optionaly persist across runs of the state graph by using the persist attribute.
- **Key Attributes**:
  - `id`: Unique ID for the history pseudo-state.
  - `type`: `"deep"` or `"shallow"`. Deep history recurses into nested sub-states; shallow history only remembers the top level.
  - `persist`: `"none"`, `"per-user"`. None is the default behavior where the history is reset once the top level `<final>` element is reached. per-user means that if the same userid is passed to the runtime runtime when initializing, then the history state will re-hydrate with the same value as last time.
- **How it functions**

  1. **Placed Inside a Compound or Parallel State:**

  - You typically define a `<history>` element as a child of a `<state>` or `<parallel>`.
  - It captures where you were **inside** that parent state the last time you left it.

  2. **Shallow vs. Deep History (`type="shallow"` or `type="deep"`):**

  - **Shallow (`type="shallow")`:** Remembers only the **immediate** child state that was active. When re-entering, you go to that child. But if that child itself was a compound state, you start over in its **default initial** sub-state.
  - **Deep (`type="deep")`:** Remembers the **entire** nested sub-state configuration, i.e. all the levels below. This effectively picks up exactly where you left off, no matter how deep the nesting was.

  3. **Default State for “First Time” Entering:**

  - A `<history>` element includes a `<transition>` child describing where to go if there is **no stored history** (i.e., the parent has never been entered before).
  - For example:
    ```xml
    <history id="h1" type="shallow">
      <transition target="childStateA"/>
    </history>
    ```
  - If the history is not set yet (first time), you enter `childStateA`. Otherwise, you re-enter whichever child (or nested sub-state) was last active.

  4. **Authoring a Transition to `<history>`:**

  - Anywhere in your SCXML, if you write a transition to the `<history>` state’s `id`, the SCXML engine re-enters the **parent** state, but using the remembered configuration.
  - For example, if you have:
    ```xml
    <transition event="back" target="h1"/>
    ```
    and `h1` is a `<history>` child of state `S`, then the machine will re-enter `S` the way it was the last time `S` was exited.

  6. **How `<history>` Works with `<final>` States:**

  - If you left the parent state while one of its children was in `<final>`, that’s also recorded. Re-entering the `<history>` can theoretically bring you back to that final sub-state (though typically once a region is final, it won’t do more work).
  - In practice, many designs avoid storing a final sub-state in history, but it’s permissible.

  7. **Multiple `<history>` Elements?**

  - A single parent `<state>` or `<parallel>` can define _both_ a shallow and a deep `<history>` if desired. Each would have a different `id`. In certain advanced use cases, you might have transitions to either the shallow or deep version.

- **Allowed Children**:
  - `<transition>` (defining what happens if no history is stored yet, or when returning to history)
  - `<onentry>`, `<onexit>`, `<on>`, `<script>`, `<__any custom element__>`, `<datamodel>` (though these are less common in practice)

Below is a **developer-oriented** explanation of how **History Elements** (`<history>`) in SCXML work—what you need to know when authoring SCXML with history states. This focuses on **how you design** with `<history>`, rather than the internal algorithm the runtime uses to process them.

#### Minimal Example

Below is a small demonstration:

```xml
<scxml version="1.0" xmlns="http://www.w3.org/2005/07/scxml" initial="outer" datamodel="ecmascript">

  <state id="outer" initial="innerA">
    <state id="innerA">
      <transition event="switch" target="innerB"/>
      <transition event="goHistory" target="myHistory"/>
    </state>

    <state id="innerB">
      <transition event="switch" target="innerA"/>
      <transition event="goHistory" target="myHistory"/>
    </state>

    <!-- The history pseudo-state: If we haven't used it before,
         we go to innerA by default. Otherwise, we go to whichever substate was last active. -->
    <history id="myHistory" type="shallow">
      <transition target="innerA"/>
    </history>
  </state>

</scxml>
```

**Behavior**:

- The machine starts in `outer`, which in turn uses `innerA` as its initial child.
- If an event `switch` occurs, you toggle to `innerB`.
- If an event `goHistory` occurs, you **re-target** the transition to `myHistory`.
  - The first time it’s used, it goes to `innerA` (the default).
  - If you had last been in `innerB`, and you exited `outer`, then returning via `myHistory` jumps back to `innerB`.

---

## 3. Transitions and Executable Content

### 3.1 `<transition>`

- **Purpose**: Defines a transition between states (or from `<history>` or `<parallel>` etc.).
- **Key Attributes**:
  - `event`: The event(s) that trigger the transition (space-delimited if multiple).
  - `cond`: A Boolean expression that must evaluate to true for the transition to occur.
  - `target`: The state(s) that will become active when the transition is taken.
- **How it functions**

  1. **Placed Inside a State (or Parallel) Element:**

  ```xml
  <state id="someState">
    ...
    <transition event="myEvent" target="otherState" />
  </state>
  ```

  - The “source state” is implicitly the `<state>` (or `<parallel>`) that contains the `<transition>`.

  2. **Event Trigger (`event` Attribute):**

  - The simplest way to trigger a transition is to give it an `event="someEventName"` attribute.
  - The transition fires if the incoming event’s name matches (including prefix matching rules, e.g. `event="error"` matches `error`, `error.someThing`, etc.).
  - You can also specify multiple events like `event="start stop"` to handle either event.

  3. **Condition Guard (`cond` Attribute):**

  - You can add a `cond` (a boolean expression) that must be true for the transition to fire:
    ```xml
    <transition event="start" cond="x > 0" target="running"/>
    ```
  - The event must match **and** the condition must evaluate to `true`.

  4. **Eventless Transition (No `event` Attribute):**

  - A transition with **no** `event` is taken **immediately** once the machine enters the source state, if its `cond` (if any) is satisfied.
  - This is also referred to as **“eventless”** or **“immediate”** transition.
  - For example:
    ```xml
    <transition cond="doneLoading" target="nextState"/>
    ```
    This transition occurs automatically if `doneLoading` evaluates to `true` upon entering the source state (or becoming active later).

  5. **Target or No Target:**

  - `target` names one (or more) states by `id`.
  - If **no `target` is specified**, it is called a **targetless** transition—it **does not** leave the source state or change the state configuration but still runs any executable content inside it.

  6. **Executable Content Inside `<transition>`:**

  - You can place actions (e.g., `<assign>`, `<log>`, `<send>`, `<raise>`, etc.) **inside** a `<transition>`.
  - The SCXML engine runs that content **after** the source state’s `<onexit>` code but **before** entering the target state’s `<onentry>` code.

  Example:

  ```xml
  <transition event="start" target="running">
    <log expr="'Transitioning from stopped to running'"/>
  </transition>
  ```

  7. **`type="external"` vs. `type="internal"`:**

  - By default, transitions are **external**. This means the source state is always exited, then the target state entered.
  - If `type="internal"` **and** the source is a compound state targeting a descendant, then the source state is **not** re-exited and re-entered; you just move directly into the child sub-state.
  - In most common use cases, you don’t need to worry about `type`, because external transitions are the default behavior you want.

  8. **Transitions in Document Order Have Priority:**

  - When multiple transitions match the same event and conditions, SCXML picks the **first** in document order.
  - In practice, put your most specific or highest-priority transitions first.

- **Allowed Children**:
  - Executable actions, such as:
    - `<raise>`
    - `<send>`
    - `<log>`
    - `<if>` / `<elseif>` / `<else>`
    - `<foreach>`
    - `<assign>`
    - `<script>`
    - `<cancel>`

#### Minimal Example

```xml
<state id="idle">
  <transition event="start" cond="mode=='auto'" target="running">
    <log expr="'Switching to running (auto mode)'" />
  </transition>
  <transition event="start" cond="mode=='manual'" target="setup"/>
  <!-- No event => an eventless transition that triggers immediately if battery<10% -->
  <transition cond="battery < 10" target="lowBattery"/>
</state>
```

**Behavior**:

- If an event `start` arrives, and `mode=='auto'`, the machine transitions to `running` (after logging).
- If an event `start` arrives, and `mode=='manual'`, the machine transitions to `setup`.
- If no event arrives but `battery < 10`, the machine transitions to `lowBattery` automatically.

### 3.2 `<onentry>`, `<onexit>`, and `<on>`

- **Purpose**:
  - `<onentry>` and `<onexit>`: Containers for executable content that run upon entering or exiting a state (respectively).
  - `<on>`: Container for executable content that runs when a specific event occurs, similar to `<onentry>` but triggered by events rather than state changes.
- **Key Attributes** (for `<on>`):
  - `event`: The event name that triggers this handler.
- **Allowed Children** (i.e., the same sorts of "action" elements as transitions):
  - `<raise>`, `<send>`, `<log>`, `<if>`, `<foreach>`, `<assign>`, `<script>`, `<cancel>`, etc.

---

## 4. Action Elements

These elements define "what to do" when certain events happen (on entry, on exit, or during a transition).

1. **`<raise>`**

   - **Purpose**: Synchronously raises an event in the current state machine.
   - **Attributes**:
     - `event`: Name of the event to raise.

2. **`<send>`**

   - **Purpose**: Sends an event (potentially to an external system or to itself).
   - **Key Attributes**:
     - `event`: The event name to send (static).
     - `eventexpr`: An expression that evaluates to the event name.
     - `target`: A static target location.
     - `targetexpr`: Dynamic expression for the target.
     - `type`: The type of event or the communication channel (e.g. `"scxml"`).
     - `typeexpr`, `id`, `idlocation`, `delay`, `delayexpr`, etc.

3. **`<cancel>`**

   - **Purpose**: Cancels an in-flight `<send>`.
   - **Attributes**:
     - `sendid`: The ID of the `<send>` to cancel.
     - `sendidexpr`: Expression that evaluates to that ID.

4. **`<log>`**

   - **Purpose**: Logs a message or value.
   - **Attributes**:
     - `label`: A string label prefixing the log.
     - `expr`: An expression to evaluate and log.

5. **`<assign>`**

   - **Purpose**: Assigns a value to a location in the data model.
   - **Attributes**:
     - `location`: The "path" or key in the data model to assign.
     - `expr`: The expression whose result is assigned.

6. **`<if>`, `<elseif>`, `<else>`**

   - **Purpose**: Conditional branching within SCXML transitions and onentry/onexit.
   - **Attributes**:
     - `cond`: Expression to evaluate to true/false.
   - **Allowed Children**:
     - Other actions (e.g., `<assign>`, `<log>`, `<send>`, `<if>`…), plus nested `<elseif>` or `<else>` for branching.

7. **`<foreach>`**

   - **Purpose**: Iterates over a collection in the data model.
   - **Attributes**:
     - `array`: Expression or reference to the array.
     - `item`, `index`: Variable names used during iteration.
     - `itemlocation`, `indexlocation`: Where to store item/index in the data model at runtime.
   - **Allowed Children**:
     - Actions to be executed for each item (like `<assign>`, `<log>`, etc.).

8. **`<script>`**
   - **Purpose**: Contains script code to be executed (often JavaScript if `datamodel="ecmascript"`).
   - **Content**: Usually text content of the script.

---

## 5. Data Model Elements

### 5.1 `<datamodel>`

- **Purpose**: Defines or updates the data environment for the state machine.
- **Allowed Children**:
  - `<data>` elements.

### 5.2 `<data>`

- **Purpose**: Initializes or holds some piece of data for the state machine.
- **Key Attributes**:
  - `id`: The unique name/identifier for this data item in the data model.
  - `expr`: Expression that initializes this data item.
  - `src`: URI or location from which to load the data (if dynamic).
- **No children** (strictly speaking, `<data>` is usually self-closing or might contain raw data in some contexts).

---

## 6. Custom Elements

### 6.1 `<__any custom element__>`

- **Purpose**: Custom elements can also be added to the spec that exicute functionality like AI text generation or audio generation
- **Key Attributes**: Whatever you define
- **Allowed Children**:
  - Custom defined elements that serve as paramaters/inputs during exicution
  - Text, or json
  - `<finalize>` (actions executed when the invoked process terminates).

### 6.2 `<finalize>`

- **Purpose**: Defines actions to perform when an invoked child process completes.
- **Allowed Children**:
  - The same action elements (`<assign>`, `<log>`, `<send>`, etc.) that appear in transitions or onentry/onexit.

---

## 7. Hierarchical/Child Relationships Summary

1. **`<scxml>`** is the root. It can contain:

   - `<state>`, `<parallel>`, `<final>` (top-level states)
   - `<datamodel>` (optional, for global data)
   - `<script>` (global scripts)
   - `<onentry>`, `<onexit>`, `<on>` (rarely used at top level, but allowed)
   - `<transition>` (top-level transitions, less common)

2. **`<state>` and `<parallel>`** can contain:

   - `<state>`, `<parallel>`, `<final>` (child states)
   - `<history>` (for historical state)
   - `<transition>` (transitions triggered within or from this state)
   - `<onentry>`, `<onexit>`, `<on>` blocks
   - `<__any custom element__>` to start external processes
   - `<datamodel>` (to redefine or expand data)
   - `<script>` (state-specific script)

3. **`<final>`** can contain:

   - `<onentry>`, `<onexit>`, `<on>`, `<script>`, `<__any custom element__>`, `<datamodel>`
   - Typically no nested states, as `<final>` is the end.

4. **`<transition>`, `<onentry>`, `<onexit>`, `<on>`, `<finalize>`** can all contain:

   - The "action" elements `<raise>`, `<send>`, `<log>`, `<if>`, `<foreach>`, `<assign>`, `<script>`, `<cancel>`, etc.

5. **`<history>`** can contain:
   - `<transition>`
   - `<onentry>`, `<onexit>`, `<on>`, `<script>`, `<__any custom element__>`, `<datamodel>` (though rarely used)

---

## 8. Eventing system & execution order

As noted in each elements description above, SCXML's exicution order is determend both by a sequential flow as well as by its event system.

### Execution Flow via Document Order

- Default Sequential Flow: In the absence of any events, your system processes elements strictly in the order they appear in the document with the exception of <parallel> whos children, except for <final> are all executed in parallel. The first element receives the initial user input, transforms (or passes through) a value, and outputs it. That output becomes the next element's input, and so on.
- Chained Input/Output: Each element either produces a new value or passes its input along as output, ensuring the sequence continues until all elements have executed.

### Event-Driven Flow

- Built-In & Custom Events: When an element raises an event—like a built-in SCXML event (e.g., done.state.someState, error.execution) or a custom event—it can cause the SCXML interpreter to jump to an event-listening transition.
- Listening with `<transition>`: You define which events a state should react to in the event attribute of `<transition>`. If a matching event arrives, the state transitions accordingly, regardless of the default document order.
